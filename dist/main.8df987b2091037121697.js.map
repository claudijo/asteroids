{"version":3,"file":"main.8df987b2091037121697.js","mappings":"i2BAAO,IAAMA,EAAM,WAAa,2BAATC,EAAS,yBAATA,EAAS,gBAC9B,OAAOA,EAAKC,QAAO,SAACC,EAAKC,GAAN,OAAcD,EAAMC,MAO5BC,EAAQ,SAACC,GAAsB,IAAhBC,EAAgB,uDAAN,EACpC,OAAO,EAAIC,MAAMF,GAAMG,QAAQC,KAAI,SAAAC,GAAC,OAAIA,EAAIJ,M,izCCPvC,IAAMK,EAAM,WAAgB,2BAAZC,EAAY,yBAAZA,EAAY,gBACjC,OAAOA,EAAQ,GAAGH,KAAI,SAACI,EAAGH,GACxB,OAAOE,EAAQX,QAAO,SAACC,EAAKY,GAC1B,OAAOZ,EAAMY,EAAOJ,KACnB,OAIMK,EAAW,SAACC,EAAMC,GAC7B,OAAOD,EAAKP,KAAI,SAACS,EAAGR,GAAJ,OAAUQ,EAAID,EAAKP,OAGxBS,EAAW,SAACC,EAAQN,GAC/B,OAAOA,EAAOL,KAAI,SAAAS,GAAC,OAAIA,EAAIE,MAGhBC,EAAS,SAAAP,GACpB,OAAOQ,KAAKC,KAAKxB,EAAAA,WAAA,IAAOe,EAAOL,KAAI,SAAAN,GAAG,gBAAIA,EAAO,UAWtCqB,EAAW,SAACR,EAAMC,GAC7B,OAAOI,EAAON,EAASC,EAAMC,KASlBQ,EAAc,SAAAC,GACzB,QAAwBA,EAAxB,GAAOL,EAAP,KAAeM,EAAf,KACA,MAAO,CACLN,EAASC,KAAKM,IAAID,GAClBN,EAASC,KAAKO,IAAIF,KAUTG,EAAS,SAACH,EAAOb,GAC5B,MAPqB,SAAAiB,GACrB,QAAeA,EAAf,GAAOC,EAAP,KAAUC,EAAV,KACMN,EAAQL,KAAKY,MAAMD,EAAGD,GAC5B,MAAO,CAACX,EAAOU,GAAYJ,GAIZQ,CAAQrB,GAAvB,SAAOsB,EAAP,KAAUC,EAAV,KACA,OAAOZ,EAAY,CAACW,EAAGC,EAAIV,KAkJhBW,EAAsB,SAACC,EAAIC,GACtC,QAAiBD,EAAjB,GAAOE,EAAP,KAAWC,EAAX,KACA,IAAiBF,EAAjB,GAAOG,EAAP,KAAWC,EAAX,KACMC,EAAKrB,EAASiB,EAAIC,GAClBI,EAAKtB,EAASmB,EAAIC,GAClBlC,EA9BoB,SAAC+B,EAAIC,EAAIC,EAAIC,GACvC,QAAeH,EAAf,GAAOJ,EAAP,KAAUU,EAAV,KACA,IAAeL,EAAf,GAAOM,EAAP,KAAUC,EAAV,KACA,IAAeN,EAAf,GAAOO,EAAP,KAAUC,EAAV,KACA,IAAeP,EAAf,GAAOQ,EAAP,KAAUC,EAAV,KACMC,GAAON,EAAIX,IAAMgB,EAAIF,IAAMC,EAAIF,IAAMD,EAAIF,GAG/C,GAAY,IAARO,EACF,OAAO,KAGT,IAAMC,IAAWF,EAAIF,IAAMC,EAAIf,IAAMa,EAAIE,IAAMC,EAAIN,IAAMO,EACnDE,IAAUT,EAAIE,IAAMG,EAAIf,IAAMW,EAAIX,IAAMgB,EAAIN,IAAMO,EAExD,OAAK,EAAIC,GAAUA,EAAS,GAAO,EAAIC,GAASA,EAAQ,EAC/C,CACLnB,EAAIkB,GAAUP,EAAIX,GAClBU,EAAIQ,GAAUN,EAAIF,IAIf,KAQGU,CAAahB,EAAIC,EAAIC,EAAIC,GACnC,OAAU,OAANlC,IAIGc,EAASiB,EAAI/B,IAAMmC,GACxBrB,EAASkB,EAAIhC,IAAMmC,GACnBrB,EAASmB,EAAIjC,IAAMoC,GACnBtB,EAASoB,EAAIlC,IAAMoC,IAGVY,EAAQ,SAACC,EAAQ3B,EAAGC,GAC/B,IAAM2B,EAAmB,CAAC5B,EAAI2B,EAAO3B,EAAGC,EAAI0B,EAAO1B,GACnD,OAlMmB,SAACb,GAAuB,2BAAZR,EAAY,iCAAZA,EAAY,kBAC3C,OAAOA,EAAQH,KAAI,SAAAK,GAAM,OAAIK,EAASC,EAAQN,MAiMvC+C,CAAMF,EAAOG,MAAOF,GAAkB,I,kvDCzN1BG,EAAAA,WACnB,WAAYC,I,4FAAQ,SAClBC,KAAKD,OAASA,EACdC,KAAKC,cAAgB,EACrBD,KAAKjC,EAAI,EACTiC,KAAKhC,EAAI,EACTgC,KAAKE,GAAK,EACVF,KAAKG,GAAK,EACVH,KAAKI,GAAK,EACVJ,KAAKK,aAAe,EACpBL,KAAKM,UAAY,E,0CAGnB,SAAKC,GACH,IAAMC,EAAKR,KAAKE,GAAKK,EAAK,IACpBE,EAAKT,KAAKG,GAAKI,EAAK,IAFjB,IAGU7D,EAAI,CAACsD,KAAKjC,EAAGiC,KAAKhC,GAAI,CAACwC,EAAIC,IAHrC,GAGRT,KAAKjC,EAHG,KAGAiC,KAAKhC,EAHL,KAKTgC,KAAKM,WAAaN,KAAKU,QAAUH,EAE7BP,KAAKjC,GAAK,KACZiC,KAAKjC,GAAK,IAERiC,KAAKhC,GAAK,KACZgC,KAAKhC,GAAK,IAERgC,KAAKjC,EAAI,KACXiC,KAAKjC,GAAK,IAERiC,KAAKhC,EAAI,KACXgC,KAAKhC,GAAI,M,oBAIb,SAAOuC,GACL,IAAMI,EAAKX,KAAKI,GAAKG,EAAK,IADjB,IAEc7D,EAAI,CAACsD,KAAKC,eAAgB,CAACU,IAFzC,GAERX,KAAKC,cAFG,O,wBAKX,SAAWM,GACT,IAAMK,EAAKZ,KAAKK,aAAehD,KAAKM,IAAIqC,KAAKC,eACvCY,EAAKb,KAAKK,aAAehD,KAAKO,IAAIoC,KAAKC,eAC7CD,KAAKE,IAAMU,EAAKL,EAAK,IACrBP,KAAKG,IAAMU,EAAKN,EAAK,M,mBAGvB,WACE,OAAOnD,EAAO,CAAC4C,KAAKE,GAAIF,KAAKG,O,yBAG/B,WAAkC,WAAtBJ,EAAsB,uDAAbC,KAAKD,OACxB,OAAOA,EACJvD,KAAI,SAAAsE,GAAK,OAAIjD,EAAO,EAAKoC,cAAea,MACxCtE,KAAI,SAAAsE,GAAK,OAAIpE,EAAI,CAAC,EAAKqB,EAAG,EAAKC,GAAI8C,Q,sBAGxC,WACE,IAAMC,EAAaf,KAAKD,OAAO3C,OACzB2C,EAASC,KAAKgB,cACpB,OAAO7E,EAAM4E,GAAYvE,KAAI,SAAAC,GAC3B,MAAO,CACLsD,EAAOtD,GACPsD,GAAQtD,EAAI,GAAKsE,S,yBAKvB,SAAYE,GAAc,UACGA,EAAaC,YADhB,IACxB,2BAAoD,KAAzCC,EAAyC,QAClD,GAAInB,KAAKoB,cAAcD,GACrB,OAAO,GAHa,8BAMxB,OAAO,I,2BAGT,SAAcA,GAAc,UACJnB,KAAKkB,YADD,IAC1B,2BAAuC,KAA5BG,EAA4B,QACrC,GAAIhD,EAAoB8C,EAAcE,GACpC,OAAO,GAHe,8BAM1B,OAAO,K,mFAlFUvB,G,+zCCDAwB,EAAAA,SAAAA,I,4SACnB,aAAc,O,4FAAA,qBACN,CAAC,CAAC,GAAK,GAAI,EAAE,IAAM,KAAO,EAAE,KAAO,O,mCAG3C,WACE,OAAOtB,KAAKgB,cAAc,K,kBAG5B,WACE,OAAOhB,KAAKgB,YAAY,CAAC,EAAE,IAAM,KAAK,Q,gFAVrBM,CAAaxB,GCWrByB,EAAY,SAACC,EAAKC,GAC7B,OAAOpE,KAAKqE,MAAMrE,KAAKsE,UAAYF,EAAMD,EAAM,GAAKA,IAGzCG,EAAS,SAACH,EAAKC,GAC1B,OAAOpE,KAAKsE,UAAYF,EAAMD,GAAOA,G,65CCblBI,EAAAA,SAAAA,I,4SACnB,aAA4B,MAAhBC,EAAgB,uDAAH,EAAG,UAC1B,IAAMC,EAAQP,EAAU,EAAG,GACrB5E,EAAUR,EAAM2F,GAAOtF,KAAI,SAAAC,GAC/B,IAAMW,EAASuE,EAAO,GAAK,GAAKE,EAChC,OAAOrE,EAAY,CAACJ,EAAQ,EAAIC,KAAK0E,GAAKtF,EAAIqF,OAJtB,OAO1B,cAAMnF,IAEDuD,GAAKyB,GAAQ,EAAG,GAAKE,EAC1B,EAAK1B,GAAKwB,GAAQ,EAAG,GAAKE,EAC1B,EAAKzB,GAAKuB,GAAQ,EAAG,GAAKE,EAE1B,EAAKA,WAAaA,EAbQ,E,8FADTD,CAAiB9B,GCLzBkC,EAAQ,SAACC,EAAKC,GACzBD,EAAIE,YACJF,EAAIG,OAAOF,EAAQ,GAAG,GAAIA,EAAQ,GAAG,IACrC,IAAK,IAAIzF,EAAI,EAAGA,EAAIyF,EAAQ9E,OAAQX,IAClCwF,EAAII,OAAOH,EAAQzF,GAAG,GAAIyF,EAAQzF,GAAG,IAEvCwF,EAAIK,aAGOC,EAAQ,SAACN,EAAKO,GACL,CAAC,aAAc,cAAe,gBAAiB,iBACvDC,SAAQ,SAAAC,GACdA,KAAQF,IACVP,EAAIS,GAAQF,EAAWE,QAKhBC,EAAgB,SAACV,EAAKO,GACjC,IAAQI,EAAsCJ,EAAtCI,UAAWC,EAA2BL,EAA3BK,YAAaC,EAAcN,EAAdM,UAE5BF,IACFX,EAAIW,UAAYA,EAChBX,EAAIc,QAGFF,GAAeC,IACjBb,EAAIY,YAAcA,EAClBZ,EAAIa,UAAYA,EAChBb,EAAIe,W,+zCC3BaC,EAAAA,SAAAA,I,4SACnB,aAAc,a,4FAAA,UACZ,cAAM,CAAC,CAAC,EAAG,GAAI,CAAC,GAAK,MAEhBC,MAAQ,GAHD,E,8FADKD,CAAenD,G,s0CCAfqD,GAAAA,SAAAA,I,4SACnB,aAAc,a,4FAAA,UACZ,cAAM,CAAC,CAAC,EAAG,GAAI,CAAC,GAAK,MAEhBD,MAAQ,EAHD,E,8FADKC,CAAiBrD,G,+0CCEjBsD,GAAAA,SAAAA,I,8SACnB,WAAYvD,GAAO,O,4FAAA,SACjB,IACMlD,EAAUR,EADF,IACeK,KAAI,SAAAC,GAE/B,OAAOe,EAAY,CADJ,GACa,EAAIH,KAAK0E,GAAKtF,EAH9B,QADG,OAOjB,cAAME,IAEDkD,MAAQA,EATI,E,gGADAuD,CAAkBtD,G,+0CCClBuD,GAAAA,SAAAA,I,8SACnB,aAAc,O,4FAAA,SACZ,IAAMvB,EAAQP,EAAU,EAAG,GACrB5E,EAAUR,EAAM2F,GAAOtF,KAAI,SAAAC,GAC/B,IAAMW,EAASuE,EAAO,IAAM,IAC5B,OAAOnE,EAAY,CAACJ,EAAQ,EAAIC,KAAK0E,GAAKtF,EAAIqF,OAJpC,OAOZ,cAAMnF,IAEDuG,MAAQ,EATD,E,gGADKG,CAA0BvD,G,0zCCW/C,IAAIwD,GAAO,KACPC,GAAY,GACZC,GAAU,GACVC,GAAkB,GAClBC,GAAqB,GACrBC,GAAa,GAIjBC,SAASC,KAAKC,YCzBd,WAAmC,IAAnBC,EAAmB,uDAAP,GACpBC,EAAUJ,SAASK,cAAc,OAEvC,OADAD,EAAQE,UAAYH,EACbC,EDsBiBG,CAAM,qCAChC,IAAMC,GAASR,SAASS,eAAe,qBACvCD,GAAOE,aAAa,SAAU,OAC9BF,GAAOE,aAAa,QAAS,OAE7B,IAAIC,IAAiB,EACjBC,IAAgB,EAChBC,IAAiB,EAErBC,OAAOC,iBAAiB,WAAW,SAAAC,GACjC,IAAIA,EAAMC,OAIV,OAAQD,EAAME,KACZ,IAAK,YACHN,IAAgB,EAChB,MACF,IAAK,aACHC,IAAiB,EACjB,MACF,IAAK,UAGHF,IAAiB,EACjB,MACF,IAAK,IAEH,IAAMQ,EAAS,IAAI9B,EAFrB,KAGyBK,GAAK0B,SAH9B,GAGGD,EAAOhH,EAHV,KAGagH,EAAO/G,EAHpB,KAIE+G,EAAO7E,GAAKoD,GAAKpD,GACjB6E,EAAO5E,GAAKmD,GAAKnD,GACjB4E,EAAO9E,cAAgBqD,GAAKrD,cAC5B8E,EAAO1E,aAAe,GACtBmD,GAAQyB,KAAKF,OAKnBL,OAAOC,iBAAiB,SAAS,SAAAC,GAC/B,OAAQA,EAAME,KACZ,IAAK,YACHN,IAAgB,EAChB,MACF,IAAK,aACHC,IAAiB,EACjB,MACF,IAAK,UACHF,IAAiB,MAQvB,ILhDyBW,GAAOC,GAAQC,GAAYC,GKgD9CpD,GAAMmC,GAAOkB,WAAW,MACxBC,ILjDmBL,GKiDOd,GAAOc,MLjDPC,GKiDcf,GAAOe,OLjDbC,GKiDqB,GLjDTC,GKiDa,GLjDG,SAACtH,EAAGC,GACtE,MAAO,CAACkH,GAAM,EAAIA,GAAQnH,EAAIqH,GAAYD,GAAO,EAAIA,GAASnH,EAAIqH,MKkD9DG,GAAW,WACflC,GAAO,IAAIhC,EACXiC,GAAYpH,EAAM,GAAGK,KAAI,SAAAC,GACvB,IAAMgJ,EAAW,IAAI7D,EAGrB,OAFA6D,EAAS1H,EAAIwD,GAAW,EAAG,GAC3BkE,EAASzH,EAAIuD,GAAW,EAAG,GACpBkE,KAETjC,GAAU,GACVC,GAAkB,GAClBE,GAAaxH,EAAM,GAAGK,KAAI,SAAAC,GACxB,OAAO,IAAI2G,IAAW,QAIpBsC,GAAO,SAACC,GAA8B,IAApBnD,EAAoB,uDAAP,GAC7BN,EAAUyD,EAASnJ,KAAI,0BAAEuB,EAAF,KAAKC,EAAL,YAAYuH,GAAexH,EAAGC,MAC3DiE,GAAI2D,OACJ5D,EAAMC,GAAKC,GACXK,EAAMN,GAAKO,GACXG,EAAcV,GAAKO,GACnBP,GAAI4D,WAGFC,GAAWC,YAAYC,MA2K3BR,KAzKiB,SAAXS,IACJ,IAAMD,EAAMD,YAAYC,MAClBE,EAAUF,EAAMF,GAatB,GAZAA,GAAWE,EACX/D,GAAIkE,UAAU,EAAG,EAAG/B,GAAOc,MAAOd,GAAOe,QAGzCxB,GAAWnH,KAAI,SAAA4J,GACbV,GAAKU,EAAUpF,cAAe,CAC5B4B,UAAW,QACXyD,YAAa,OACbC,WAAY,QAIZ/B,GAAgB,CAClBjB,GAAKjD,aAAe,GAGpB,IADA,IAAMkG,EAAuBhF,EAAU,EAAE,GAChC9E,EAAI,EAAGA,EAAI8J,EAAsB9J,IAAK,CAC7C,IAAM+J,EAAiB,IAAIrD,GADkB,KAENG,GAAKmD,OAFC,GAE5CD,EAAezI,EAF6B,KAE1ByI,EAAexI,EAFW,KAG7CwI,EAAetG,GAAKoD,GAAKpD,GACzBsG,EAAerG,GAAKmD,GAAKnD,GACzBqG,EAAetD,MAAQ3B,EAAU,EAAG,IACpCiF,EAAevG,cAAgBqD,GAAKrD,cAAgB5C,KAAK0E,GAAKJ,GAAQ,GAAK,IAC3E6E,EAAenG,aAAekB,EAAU,GAAG,IAC3CkC,GAAgBwB,KAAKuB,SAGvBlD,GAAKjD,aAAe,EAGlBmE,KAAkBC,GACpBnB,GAAKrD,eAAiB,IACZuE,IAAiBC,KAC3BnB,GAAKrD,eAAiB,IAGxBqD,GAAKzF,OAAOqI,GACZ5C,GAAKoD,WAAWR,GAChB5C,GAAKqD,KAAKT,GAEVR,GAAKpC,GAAKtC,cAAe,CACvB8B,UAAW,EACXD,YAAa,OACbD,UAAW,aAGb,IAAMgE,EAAqB,GACvBC,GAAQ,EAEZtD,GAAYA,GAAUuD,QAAO,SAAArB,GACvBA,EAASsB,YAAYzD,MACvBuD,GAAQ,GAF6B,Q,ioBAAA,CAKlBrD,IALkB,IAKvC,2BAA8B,KAAnBuB,EAAmB,QAC5B,GAAIU,EAASsB,YAAYhC,GAAS,CAIhC,IADA,IAAMiC,EAA0BzF,EAAU,GAAG,KAAO,EAAIkE,EAAS5D,YACxDpF,EAAI,EAAGA,EAAIuK,EAAyBvK,IAAK,CAChD,IAAMwK,EAAoB,IAAI5D,GAC9B4D,EAAkBlJ,EAAI0H,EAAS1H,EAAI4D,GAAQ,GAAK,IAChDsF,EAAkBjJ,EAAIyH,EAASzH,EAAI2D,GAAQ,GAAK,IAChD,IAAM1B,EAAgB0B,EAAO,EAAa,EAAVtE,KAAK0E,IACrC,KAAevE,EAAY,CAAC,EAAGyC,IAA/B,GAAKC,EAAL,KAASC,EAAT,KACA8G,EAAkB/G,GAAKA,EACvB+G,EAAkB9G,GAAKA,EACvB8G,EAAkB/D,MAAQ3B,EAAU,EAAE,GACtC0F,EAAkBhH,cAAgBA,EAClCgH,EAAkB5G,aAAekB,GAAW,GAAG,GAC/CmC,GAAmBuB,KAAKgC,GAY1B,OATAlC,EAAO7B,MAAQ,EACXuC,EAAS5D,WAAa,GACxB1F,EAAM,GAAGsG,SAAQ,SAAA7F,GACf,IAAMsK,EAAO,IAAItF,EAAS6D,EAAS5D,WAAa,GAChDqF,EAAKnJ,EAAI0H,EAAS1H,EAClBmJ,EAAKlJ,EAAIyH,EAASzH,EAClB4I,EAAmB3B,KAAKiC,OAGrB,IAjC4B,8BAqCvC,OAAO,KAGT3D,GAAY,GAAH,UAAOA,IAAcqD,GAE9BjD,GAAWlB,SAAQ,SAAA2D,GACjB7C,GAAUd,SAAQ,SAAAgD,GAChB,SAAiBhG,EAAM2G,EAAYX,EAAS1H,EAAG0H,EAASzH,GAAxD,GAAOmJ,EAAP,KAAWC,EAAX,KACA3B,EAASvF,IAAMiH,GAAMjB,EAAU,KAC/BT,EAAStF,IAAMiH,GAAMlB,EAAU,QAGjC,SAAiBzG,EAAM2G,EAAY9C,GAAKvF,EAAGuF,GAAKtF,GAAhD,GAAOmJ,EAAP,KAAWC,EAAX,KACA9D,GAAKpD,IAAMiH,GAAMjB,EAAU,KAC3B5C,GAAKnD,IAAMiH,GAAMlB,EAAU,QAI7B3C,GAAUd,SAAQ,SAAAgD,GAChBA,EAASkB,KAAKT,GACdT,EAAS5H,OAAOqI,GAChBR,GAAKD,EAASzE,cAAe,CAC3B8B,UAAW,EACXD,YAAa,QACbD,UAAW,iBAIfY,GAAUA,GAAQsD,QAAO,SAAA/B,GACvB,OAAOA,EAAOzE,UAAYyE,EAAO7B,UAG3BT,SAAQ,SAAAsC,GACdA,EAAO2B,WAAWR,GAClBnB,EAAO4B,KAAKT,GAEZR,GAAKX,EAAO/D,cAAe,CACzB8B,UAAW,EACXD,YAAa,YAIjBY,GAAkBA,GAAgBqD,QAAO,SAAAO,GACvC,OAAOA,EAAS/G,UAAY+G,EAASnE,UAGvBT,SAAQ,SAAA4E,GACtBA,EAASX,WAAWR,GACpBmB,EAASV,KAAKT,GACdR,GAAK2B,EAASrG,cAAe,CAC3B8B,UAAW,EACXD,YAAa,YAAF,OAActB,EAAU,IAAI,KAA5B,cAAuC,EAAI8F,EAAS/G,UAAY+G,EAASnE,MAAzE,KACXmD,YAAa,QACbC,WAAY,QAIhB5C,GAAqBA,GAAmBoD,QAAO,SAAAO,GAC7C,OAAOA,EAAS/G,UAAY+G,EAASnE,UAGpBT,SAAQ,SAAA4E,GACzBA,EAASX,WAAWR,GACpBmB,EAASV,KAAKT,GACd,IAAMoB,EAAQ/F,EAAU,IAAI,KAC5BmE,GAAK2B,EAASrG,cAAe,CAC3B4B,UAAW,QAAF,OAAU0E,EAAQ,GAAlB,YAAwBA,EAAxB,YAAiCA,EAAQ,GAAzC,YAAgD,EAAID,EAAS/G,UAAY+G,EAASnE,MAAlF,KACTmD,YAAa,QACbC,WAAY,OAKZO,GACFrB,KAGF+B,sBAAsBtB,GAIxBA,K","sources":["webpack://asteroids/./src/libs/array.js","webpack://asteroids/./src/libs/vector.js","webpack://asteroids/./src/models/polygon.js","webpack://asteroids/./src/models/ship.js","webpack://asteroids/./src/libs/number.js","webpack://asteroids/./src/models/asteroid.js","webpack://asteroids/./src/utils/canvas.js","webpack://asteroids/./src/models/bullet.js","webpack://asteroids/./src/models/particle.js","webpack://asteroids/./src/models/black-hole.js","webpack://asteroids/./src/models/explosion-particle.js","webpack://asteroids/./src/index.js","webpack://asteroids/./src/templates/stage.js"],"sourcesContent":["export const sum = (...nums) => {\n  return nums.reduce((acc, num) => acc + num);\n}\n\nexport const multiply = (...nums) => {\n  return nums.reduce((acc, num) => acc * num);\n}\n\nexport const range = (size, startAt = 0) => {\n  return [...Array(size).keys()].map(i => i + startAt);\n}\n\nexport const zip = (...arrays) => {\n  return arrays[0].map((_, i) => {\n    return arrays.map(array => array[i]);\n  });\n}\n\nexport const remove = (arr, item) => {\n  const i = arr.indexOf(item);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n}","import { range, sum, zip } from './array';\n\nexport const add = (...vectors) => {\n  return vectors[0].map((_, i) => {\n    return vectors.reduce((acc, vector) => {\n      return acc + vector[i];\n    }, 0);\n  });\n};\n\nexport const subtract = (vec1, vec2) => {\n  return vec1.map((n, i) => n - vec2[i]);\n};\n\nexport const multiply = (scalar, vector) => {\n  return vector.map(n => n * scalar);\n};\n\nexport const length = vector => {\n  return Math.sqrt(sum(...vector.map(num => num ** 2)));\n};\n\nexport const translate = (translation, ...vectors) => {\n  return vectors.map(vector => add(translation, vector));\n};\n\nexport const scale = (scalar, ...vectors) => {\n  return vectors.map(vector => multiply(scalar, vector));\n};\n\nexport const distance = (vec1, vec2) => {\n  return length(subtract(vec1, vec2));\n};\n\nexport const perimeter = (...vectors) => {\n  return sum(...vectors.map((vector, i) => {\n    return distance(vector, vectors[(i + 1) % vectors.length]);\n  }));\n};\n\nexport const toCartesian = polar => {\n  const [length, angle] = polar;\n  return [\n    length * Math.cos(angle),\n    length * Math.sin(angle),\n  ];\n};\n\nexport const toPolar = cartesian => {\n  const [x, y] = cartesian;\n  const angle = Math.atan2(y, x);\n  return [length(cartesian), angle];\n};\n\nexport const rotate = (angle, vector) => {\n  const [l, a] = toPolar(vector);\n  return toCartesian([l, a + angle]);\n};\n\n// Measure vector alignment. Used to check if vectors are perpendicular without\n// doing any trigonometry.\nexport const dot = (vec1, vec2) => {\n  const products = vec1.map((n, i) => n * vec2[i]);\n  return sum(...products);\n};\n\nexport const angleBetween = (vec1, vec2) => {\n  return Math.acos(dot(vec1, vec2) / (length(vec1) * length(vec2)));\n};\n\n// Measuring oriented area. Only meaningful for 3d vectors. Cross product is\n// orientation dependant and helps keeping track of orientation in our\n// computations. Given two input vectors, the cross product outputs a result\n// that is perpendicular to both, and how perpendicular they input vectors are\n// (ie. how big area the two input vectors span). When drawing 3d on a 2d canvas,\n// the cross product helps us decide which polygons are visible\nexport const cross = (u, v) => {\n  const [ux, uy, uz] = u;\n  const [vx, vy, vz] = v;\n  return [\n    uy * vz - uz * vy,\n    uz * vx - ux * vz,\n    ux * vy - uy * vx,\n  ];\n};\n\n// extracts the part of any 3D vector pointing in a given direction\nexport const component = (vector, direction) => {\n  return dot(vector, direction) / length(direction);\n};\n\nexport const vectorTo2d = (vector, rightDir = [1, 0, 0], upDir = [0, 1, 0]) => {\n  return [\n    component(vector, rightDir),\n    component(vector, upDir),\n  ];\n};\n\nexport const faceTo2d = (face, rightDir = [1, 0, 0], upDir = [0, 1, 0]) => {\n  return face.map(vertex => vectorTo2d(vertex, rightDir, upDir));\n};\n\n// takes a vector and returns another in the same direction but with length 1\nexport const unit = vector => {\n  return multiply(1 / length(vector), vector);\n};\n\n// takes a face and gives us a vector perpendicular to it\nexport const normal = face => {\n  return cross(subtract(face[1], face[0]), subtract(face[2], face[0]));\n};\n\nexport const rotateX = (angle, vector) => {\n  const [x, y, z] = vector;\n  const [rotatedY, rotatedZ] = rotate(angle, [y, z]);\n  return [x, rotatedY, rotatedZ];\n};\n\nexport const rotateY = (angle, vector) => {\n  const [x, y, z] = vector;\n  const [rotatedX, rotatedZ] = rotate(angle, [x, z]);\n  return [rotatedX, y, rotatedZ];\n};\n\nexport const rotateZ = (angle, vector) => {\n  const [x, y, z] = vector;\n  const [rotatedX, rotatedY] = rotate(angle, [x, y]);\n  return [rotatedX, rotatedY, z];\n};\n\nexport const linearCombination = (scalars, ...vectors) => {\n  const scaled = scalars.map((s, i) => multiply(s, vectors[i]));\n  return add(...scaled);\n};\n\nexport const multiplyMatrixVector = (matrix, vector) => {\n  return linearCombination(vector, ...zip(...matrix));\n};\n\nexport const matrixMultiply = (a, b) => {\n  return a.map(row => {\n    return zip(...b).map(col => {\n      return dot(row, col);\n    });\n  });\n};\n\nexport const translate3d = (translation, vector) => {\n  const [a, b, c] = translation;\n  const [x, y, z] = vector;\n  const m = [\n    [1, 0, 0, a],\n    [0, 1, 0, b],\n    [0, 0, 1, c],\n    [0, 0, 0, 1],\n  ];\n  const v = [x, y, z, 1];\n  const [xOut, yOut, zOut, _] = multiplyMatrixVector(m, v);\n  return [xOut, yOut, zOut];\n};\n\nexport const inferMatrix = (n, transformation) => {\n  const d = range(n);\n\n  const standardBasisVector = d.map(row => {\n    return d.map(col => {\n      return row === col ? 1 : 0;\n    });\n  });\n\n  const cols = standardBasisVector.map(vector => transformation(vector));\n  return zip(...cols);\n};\n\n// From https://stackoverflow.com/a/24392281 and https://stackoverflow.com/a/58657254\n// Alternative approach might use https://github.com/lovasoa/linear-solve/blob/master/gauss-jordan.js\n// returns intersection point if the line from (a,b)->(c,d) intersects with (p,q)->(r,s)\nexport const intersection = (u1, u2, v1, v2) => {\n  const [a, b] = u1;\n  const [c, d] = u2;\n  const [p, q] = v1;\n  const [r, s] = v2;\n  const det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  // Parallel lines\n  if (det === 0) {\n    return null;\n  }\n\n  const lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n  const gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n\n  if ((0 < lambda && lambda < 1) && (0 < gamma && gamma < 1)) {\n    return [\n      a + lambda * (c - a),\n      b + lambda * (d - b),\n    ];\n  }\n\n  return null;\n};\n\nexport const doSegmentsIntersect = (s1, s2) => {\n  const [u1, u2] = s1;\n  const [v1, v2] = s2;\n  const d1 = distance(u1, u2);\n  const d2 = distance(v1, v2);\n  const i = intersection(u1, u2, v1, v2);\n  if (i === null) {\n    return false;\n  }\n\n  return distance(u1, i) <= d1 &&\n    distance(u2, i) <= d1 &&\n    distance(v1, i) <= d2 &&\n    distance(v2, i) <= d2;\n};\n\nexport const field = (source, x, y) => {\n  const relativePosition = [x - source.x, y - source.y];\n  return scale(source.force, relativePosition)[0];\n}","import { add, doSegmentsIntersect, length, rotate } from '../libs/vector';\nimport { range } from '../libs/array';\n\nexport default class Polygon {\n  constructor(points) {\n    this.points = points;\n    this.rotationAngle = 0;\n    this.x = 0;\n    this.y = 0;\n    this.vx = 0;\n    this.vy = 0;\n    this.vr = 0;\n    this.acceleration = 0;\n    this.travelled = 0;\n  }\n\n  move(ms, ) {\n    const dx = this.vx * ms / 1000;\n    const dy = this.vy * ms / 1000;\n    [this.x, this.y] = add([this.x, this.y], [dx, dy]);\n\n    this.travelled += this.speed() / ms;\n\n    if (this.x < -11) {\n      this.x += 22\n    }\n    if (this.y < -11) {\n      this.y += 22\n    }\n    if (this.x > 11) {\n      this.x -= 22\n    }\n    if (this.y > 11) {\n      this.y -=22\n    }\n  }\n\n  rotate(ms) {\n    const dr = this.vr * ms / 1000;\n    [this.rotationAngle] = add([this.rotationAngle], [dr]);\n  }\n\n  accelerate(ms) {\n    const ax = this.acceleration * Math.cos(this.rotationAngle);\n    const ay = this.acceleration * Math.sin(this.rotationAngle);\n    this.vx += ax * ms / 1000\n    this.vy += ay * ms / 1000\n  }\n\n  speed() {\n    return length([this.vx, this.vy]);\n  }\n\n  transformed(points = this.points) {\n    return points\n      .map(point => rotate(this.rotationAngle, point))\n      .map(point => add([this.x, this.y], point));\n  }\n\n  segments() {\n    const pointCount = this.points.length;\n    const points = this.transformed();\n    return range(pointCount).map(i => {\n      return [\n        points[i],\n        points[(i + 1) % pointCount]\n      ]\n    })\n  }\n\n  doesCollide(otherPolygon) {\n    for (const otherSegment of otherPolygon.segments()) {\n      if (this.doesIntersect(otherSegment)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  doesIntersect(otherSegment) {\n    for (const segment of this.segments()) {\n      if (doSegmentsIntersect(otherSegment, segment)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","import Polygon from './polygon';\n\nexport default class Ship extends Polygon {\n  constructor() {\n    super([[0.5, 0], [-0.25, 0.25], [-0.25, -0.25]]);\n  }\n\n  muzzle() {\n    return this.transformed()[0];\n  }\n\n  tail() {\n    return this.transformed([[-0.25, 0]])[0];\n  }\n\n  // laserSegment() {\n  //   const dist = 20 * Math.sqrt(2);\n  //   const [x, y] = this.transformed()[0]; // Coordinates for the tip of the ship\n  //   return [\n  //     [x, y],\n  //     [x + dist * Math.cos(this.rotationAngle), y + dist * Math.sin(this.rotationAngle)],\n  //   ];\n  // }\n}","export const clamp = (num, min, max) => {\n  return Math.max(min, Math.min(num, max));\n}\n\nexport const valueMap = (outMin, outMax, inMin, inMax, inValue) => {\n  const diffIn = inValue - inMin;\n  const rangeIn = inMax - inMin;\n  const percentage = diffIn / rangeIn;\n\n  const diff = outMax - outMin;\n  return outMin + diff * percentage;\n}\n\nexport const randomInt = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport const random = (min, max) => {\n  return Math.random() * (max - min) + min;\n}","import Polygon from './polygon';\nimport { randomInt, random } from '../libs/number';\nimport { toCartesian } from '../libs/vector';\nimport { range } from '../libs/array';\n\nexport default class Asteroid extends Polygon {\n  constructor(generation = 1) {\n    const sides = randomInt(5, 9);\n    const vectors = range(sides).map(i => {\n      const length = random(0.5, 1) / generation;\n      return toCartesian([length, 2 * Math.PI * i / sides]);\n    });\n\n    super(vectors);\n\n    this.vx = random(-1, 1) * generation;\n    this.vy = random(-1, 1) * generation;\n    this.vr = random(-1, 1) * generation;\n\n    this.generation = generation;\n  }\n}","export const trace = (ctx, polygon) => {\n  ctx.beginPath();\n  ctx.moveTo(polygon[0][0], polygon[0][1]);\n  for (let i = 1; i < polygon.length; i++) {\n    ctx.lineTo(polygon[i][0], polygon[i][1]);\n  }\n  ctx.closePath();\n}\n\nexport const shade = (ctx, appearance) => {\n  const shadowProps = ['shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'];\n  shadowProps.forEach(prop => {\n    if (prop in appearance) {\n      ctx[prop] = appearance[prop];\n    }\n  })\n}\n\nexport const fillAndStroke = (ctx, appearance) => {\n  const { fillStyle, strokeStyle, lineWidth } = appearance;\n\n  if (fillStyle) {\n    ctx.fillStyle = fillStyle;\n    ctx.fill();\n  }\n\n  if (strokeStyle && lineWidth) {\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n  }\n}\n\nexport const toPixels = (width, height, localWidth, localHeight) => (x, y) => {\n  return [width/2 + width * x / localWidth, height/2 - height * y / localHeight];\n}","import Polygon from './polygon';\n\nexport default class Bullet extends Polygon {\n  constructor() {\n    super([[0, 0], [0.5, 0]]);\n\n    this.reach = 50;\n  }\n}","import Polygon from './polygon';\n\nexport default class Particle extends Polygon {\n  constructor() {\n    super([[0, 0], [0.1, 0]]);\n\n    this.reach = 6;\n  }\n}","import Polygon from './polygon';\nimport { toCartesian } from '../libs/vector';\nimport { range } from '../libs/array';\n\nexport default class BlackHole extends Polygon {\n  constructor(force) {\n    const sides = 20;\n    const vectors = range(sides).map(i => {\n      const length = 0.5;\n      return toCartesian([length, 2 * Math.PI * i / sides]);\n    });\n\n    super(vectors);\n\n    this.force = force;\n  }\n}","import { random, randomInt } from '../libs/number';\nimport { range } from '../libs/array';\nimport { toCartesian } from '../libs/vector';\nimport Polygon from './polygon';\n\nexport default class ExplosionParticle extends Polygon {\n  constructor() {\n    const sides = randomInt(3, 6);\n    const vectors = range(sides).map(i => {\n      const length = random(0.05, 0.1);\n      return toCartesian([length, 2 * Math.PI * i / sides]);\n    });\n\n    super(vectors);\n\n    this.reach = 6;\n  }\n}","import Ship from './models/ship';\nimport { range } from './libs/array';\nimport Asteroid from './models/asteroid';\nimport { random, randomInt } from './libs/number';\nimport stage from './templates/stage';\nimport { fillAndStroke, shade, toPixels, trace } from './utils/canvas';\nimport { field, length, toCartesian } from './libs/vector';\nimport Bullet from './models/bullet';\nimport Particle from './models/particle';\nimport './style/main.css';\n// import laserAudioUrl from './audio/laser.mp3';\n// import explosionAudioUrl from './audio/explosion.mp3';\n// import rocketAudioUrl from './audio/rocket.mp3';\nimport BlackHole from './models/black-hole';\nimport ExplosionParticle from './models/explosion-particle';\n\nlet ship = null;\nlet asteroids = [];\nlet bullets = [];\nlet thrustParticles = [];\nlet explosionParticles = [];\nlet blackHoles = [];\n\n// const laserAudio = new Audio(laserAudioUrl);\n\ndocument.body.appendChild(stage('<canvas id=\\'game-action-layer\\'/>'));\nconst canvas = document.getElementById('game-action-layer');\ncanvas.setAttribute('height', '400');\ncanvas.setAttribute('width', '400');\n\nlet isAccelerating = false;\nlet isTurningLeft = false;\nlet isTurningRight = false;\n\nwindow.addEventListener('keydown', event => {\n  if (event.repeat) {\n    return;\n  }\n\n  switch (event.key) {\n    case 'ArrowLeft':\n      isTurningLeft = true;\n      break;\n    case 'ArrowRight':\n      isTurningRight = true;\n      break;\n    case 'ArrowUp':\n      // const rocketAudio = new Audio(rocketAudioUrl);\n      // rocketAudio.play();\n      isAccelerating = true;\n      break;\n    case ' ':\n      // laserAudio.play();\n      const bullet = new Bullet();\n      [bullet.x, bullet.y] = ship.muzzle();\n      bullet.vx = ship.vx;\n      bullet.vy = ship.vy;\n      bullet.rotationAngle = ship.rotationAngle;\n      bullet.acceleration = 40;\n      bullets.push(bullet)\n      break;\n  }\n});\n\nwindow.addEventListener('keyup', event => {\n  switch (event.key) {\n    case 'ArrowLeft':\n      isTurningLeft = false;\n      break;\n    case 'ArrowRight':\n      isTurningRight = false;\n      break;\n    case 'ArrowUp':\n      isAccelerating = false;\n      break;\n    case ' ':\n      // isFiringLaser = false;\n      break;\n  }\n});\n\nconst ctx = canvas.getContext('2d');\nconst mapCoordinates = toPixels(canvas.width, canvas.height, 20, 20);\n\nconst newRound = () => {\n  ship = new Ship();\n  asteroids = range(8).map(i => {\n    const asteroid = new Asteroid();\n    asteroid.x = randomInt(-9, 9);\n    asteroid.y = randomInt(-9, 9);\n    return asteroid;\n  });\n  bullets = [];\n  thrustParticles = [];\n  blackHoles = range(1).map(i => {\n    return new BlackHole(-0.1);\n  })\n}\n\nconst draw = (polygons, appearance = {}) => {\n  const polygon = polygons.map(([x, y]) => mapCoordinates(x, y));\n  ctx.save();\n  trace(ctx, polygon);\n  shade(ctx, appearance);\n  fillAndStroke(ctx, appearance);\n  ctx.restore();\n};\n\nlet lastTime = performance.now();\n\nconst gameLoop = () => {\n  const now = performance.now();\n  const elapsed = now - lastTime;\n  lastTime = now;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n\n  blackHoles.map(blackHole => {\n    draw(blackHole.transformed(), {\n      fillStyle: 'Black',\n      shadowColor: 'Gray',\n      shadowBlur: 16,\n    });\n  })\n\n  if (isAccelerating) {\n    ship.acceleration = 12;\n\n    const thrustParticlesCount = randomInt(1,5);\n    for (let i = 0; i < thrustParticlesCount; i++) {\n      const thrustParticle = new Particle();\n      [thrustParticle.x, thrustParticle.y] = ship.tail();\n      thrustParticle.vx = ship.vx;\n      thrustParticle.vy = ship.vy;\n      thrustParticle.reach = randomInt(3, 10)\n      thrustParticle.rotationAngle = ship.rotationAngle - Math.PI + random(-0.2, 0.2);\n      thrustParticle.acceleration = randomInt(20,30);\n      thrustParticles.push(thrustParticle);\n    }\n  } else {\n    ship.acceleration = 0;\n  }\n\n  if (isTurningLeft && !isTurningRight) {\n    ship.rotationAngle += 0.1;\n  } else if (!isTurningLeft && isTurningRight) {\n    ship.rotationAngle -= 0.1;\n  }\n\n  ship.rotate(elapsed);\n  ship.accelerate(elapsed);\n  ship.move(elapsed);\n\n  draw(ship.transformed(), {\n    lineWidth: 1,\n    strokeStyle: 'Blue',\n    fillStyle: 'Lavender',\n  });\n\n  const scatteredAsteroids = [];\n  let crash = false;\n\n  asteroids = asteroids.filter(asteroid => {\n    if (asteroid.doesCollide(ship)) {\n      crash = true;\n    }\n\n    for (const bullet of bullets) {\n      if (asteroid.doesCollide(bullet)) {\n        // const explosionAudio = new Audio(explosionAudioUrl);\n        // explosionAudio.play();\n        const explosionParticlesCount = randomInt(30,50) * (4 - asteroid.generation);\n        for (let i = 0; i < explosionParticlesCount; i++) {\n          const explosionParticle = new ExplosionParticle();\n          explosionParticle.x = asteroid.x + random(-0.2, 0.2)\n          explosionParticle.y = asteroid.y + random(-0.2, 0.2)\n          const rotationAngle = random(0, Math.PI * 2);\n          let [vx, vy] = toCartesian([3, rotationAngle])\n          explosionParticle.vx = vx;\n          explosionParticle.vy = vy;\n          explosionParticle.reach = randomInt(2,5);\n          explosionParticle.rotationAngle = rotationAngle;\n          explosionParticle.acceleration = randomInt(-3,-1);\n          explosionParticles.push(explosionParticle);\n        }\n\n        bullet.reach = 0;\n        if (asteroid.generation < 3) {\n          range(3).forEach(_ => {\n            const chip = new Asteroid(asteroid.generation + 1);\n            chip.x = asteroid.x;\n            chip.y = asteroid.y;\n            scatteredAsteroids.push(chip);\n          })\n        }\n        return false;\n      }\n    }\n\n    return true;\n  });\n\n  asteroids = [...asteroids, ...scatteredAsteroids];\n\n  blackHoles.forEach(blackHole => {\n    asteroids.forEach(asteroid => {\n      const [gx, gy] = field(blackHole,  asteroid.x, asteroid.y);\n      asteroid.vx += gx * (elapsed / 1000);\n      asteroid.vy += gy * (elapsed / 1000);\n    })\n\n    const [gx, gy] = field(blackHole,  ship.x, ship.y);\n    ship.vx += gx * (elapsed / 1000);\n    ship.vy += gy * (elapsed / 1000);\n  });\n\n\n  asteroids.forEach(asteroid => {\n    asteroid.move(elapsed);\n    asteroid.rotate(elapsed);\n    draw(asteroid.transformed(), {\n      lineWidth: 1,\n      strokeStyle: 'Green',\n      fillStyle: 'Honeydew',\n    });\n  });\n\n  bullets = bullets.filter(bullet => {\n    return bullet.travelled < bullet.reach;\n  });\n\n  bullets.forEach(bullet => {\n    bullet.accelerate(elapsed);\n    bullet.move(elapsed);\n\n    draw(bullet.transformed(), {\n      lineWidth: 1,\n      strokeStyle: 'Red',\n    });\n  });\n\n  thrustParticles = thrustParticles.filter(particle => {\n    return particle.travelled < particle.reach;\n  });\n\n  thrustParticles.forEach(particle => {\n    particle.accelerate(elapsed);\n    particle.move(elapsed);\n    draw(particle.transformed(), {\n      lineWidth: 1,\n      strokeStyle: `rgba(255,${randomInt(128,255)},0,${(1 - particle.travelled / particle.reach)})`,\n      shadowColor: 'White',\n      shadowBlur: 1,\n    });\n  });\n\n  explosionParticles = explosionParticles.filter(particle => {\n    return particle.travelled < particle.reach;\n  });\n\n  explosionParticles.forEach(particle => {\n    particle.accelerate(elapsed);\n    particle.move(elapsed);\n    const green = randomInt(200,255);\n    draw(particle.transformed(), {\n      fillStyle: `rgba(${green - 15},${green},${green - 15},${(1 - particle.travelled / particle.reach)})`,\n      shadowColor: 'White',\n      shadowBlur: 2,\n\n    });\n  })\n\n  if (crash) {\n    newRound();\n  }\n\n  requestAnimationFrame(gameLoop);\n};\n\nnewRound();\ngameLoop();","export default (innerHtml = '') => {\n  const element = document.createElement(\"div\");\n  element.innerHTML = innerHtml;\n  return element;\n};\n\n"],"names":["sum","nums","reduce","acc","num","range","size","startAt","Array","keys","map","i","add","vectors","_","vector","subtract","vec1","vec2","n","multiply","scalar","length","Math","sqrt","distance","toCartesian","polar","angle","cos","sin","rotate","cartesian","x","y","atan2","toPolar","l","a","doSegmentsIntersect","s1","s2","u1","u2","v1","v2","d1","d2","b","c","d","p","q","r","s","det","lambda","gamma","intersection","field","source","relativePosition","scale","force","Polygon","points","this","rotationAngle","vx","vy","vr","acceleration","travelled","ms","dx","dy","speed","dr","ax","ay","point","pointCount","transformed","otherPolygon","segments","otherSegment","doesIntersect","segment","Ship","randomInt","min","max","floor","random","Asteroid","generation","sides","PI","trace","ctx","polygon","beginPath","moveTo","lineTo","closePath","shade","appearance","forEach","prop","fillAndStroke","fillStyle","strokeStyle","lineWidth","fill","stroke","Bullet","reach","Particle","BlackHole","ExplosionParticle","ship","asteroids","bullets","thrustParticles","explosionParticles","blackHoles","document","body","appendChild","innerHtml","element","createElement","innerHTML","stage","canvas","getElementById","setAttribute","isAccelerating","isTurningLeft","isTurningRight","window","addEventListener","event","repeat","key","bullet","muzzle","push","width","height","localWidth","localHeight","getContext","mapCoordinates","newRound","asteroid","draw","polygons","save","restore","lastTime","performance","now","gameLoop","elapsed","clearRect","blackHole","shadowColor","shadowBlur","thrustParticlesCount","thrustParticle","tail","accelerate","move","scatteredAsteroids","crash","filter","doesCollide","explosionParticlesCount","explosionParticle","chip","gx","gy","particle","green","requestAnimationFrame"],"sourceRoot":""}